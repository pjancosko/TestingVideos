<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Bubble Sculpture (Spinning Rings, Interactive)</title>

  <!-- A-Frame + AR.js -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
  <!-- animation-mixer for BubbleSplit.glb -->
  <script src="https://rawgit.com/donmccurdy/aframe-extras/v6.0.0/dist/aframe-extras.loaders.min.js"></script>

  <style>
    body { margin: 0; overflow: hidden; }
  </style>

  <script>
    // --------- Force Phong on all GLTF meshes ---------- 
    AFRAME.registerComponent('force-phong', {
      schema: {
        shininess:   { default: 180 },
        baseOpacity: { default: 0.08 }
      },
      init () {
        this.el.addEventListener('model-loaded', () => {
          const obj = this.el.getObject3D('mesh');
          if (!obj) return;

          obj.traverse(n => {
            if (!n.isMesh || !n.material) return;

            const base = n.material;
            const phong = new THREE.MeshPhongMaterial({
              color:       0x222244,
              emissive:    0x060a2e,
              specular:    0xffffff,
              shininess:   this.data.shininess,
              transparent: true,
              opacity:     (typeof base.opacity === 'number')
                             ? base.opacity
                             : this.data.baseOpacity,
              side:        THREE.DoubleSide,
              depthWrite:  false
            });

            if (base.map)       phong.map       = base.map;
            if (base.normalMap) phong.normalMap = base.normalMap;

            n.material = phong;
            n.material.needsUpdate = true;
          });
        });
      }
    });

// --------- Bubble-pop with Camera Mirror Effect (Fading) ---------- 
AFRAME.registerComponent('bubble-pop', {
  schema: {
    mirrorDuration: { default: 4000 }  // How long mirror stays visible
  },

  init: function () {
    const el = this.el;
    this.popped = false;
    this.mirrorVideo = null;
    
    // Setup camera feed for mirror
    this.setupCameraFeed();

    // Make this entity hittable by the raycaster
    el.classList.add('clickable');

    this.onInteract = this.popBubble.bind(this);
    el.addEventListener('click', this.onInteract);
    el.addEventListener('touchstart', this.onInteract);
  },

  setupCameraFeed: function() {
    // Create video element for camera feed
    this.mirrorVideo = document.createElement('video');
    this.mirrorVideo.setAttribute('autoplay', true);
    this.mirrorVideo.setAttribute('playsinline', true);
    this.mirrorVideo.setAttribute('muted', true);
    
    // Get user-facing camera
    navigator.mediaDevices.getUserMedia({ 
      video: { 
        facingMode: 'user',
        width: { ideal: 640 },
        height: { ideal: 480 }
      } 
    })
    .then(stream => {
      this.mirrorVideo.srcObject = stream;
    })
    .catch(err => {
      console.log('Camera access denied, using chrome mirror fallback');
    });
  },

  popBubble: function () {
    if (this.popped) return;
    this.popped = true;

    const el = this.el;
    const parent = el.parentNode;
    if (!parent) return;

    const pos = el.getAttribute('position');
    const scale = el.getAttribute('scale');
    
    // Hide original bubble
    el.setAttribute('visible', false);

    // Create mirror disc
    const mirror = document.createElement('a-circle');
    mirror.setAttribute('radius', scale.x * 0.15);
    mirror.setAttribute('position', pos);
    
    // Use camera feed or chrome mirror
    if (this.mirrorVideo && this.mirrorVideo.srcObject) {
      mirror.setAttribute('material', {
        shader: 'flat',
        src: this.mirrorVideo,
        side: 'double'
      });
    } else {
      mirror.setAttribute('material', {
        metalness: 1.0,
        roughness: 0.0,
        color: '#ffffff',
        side: 'double'
      });
    }
    
    // Animations
    mirror.setAttribute('animation__scale', 
      'property: scale; from: 0.1 0.1 0.1; to: 1 1 1; dur: 800; easing: easeOutElastic');
    mirror.setAttribute('animation__rotate', 
      'property: rotation.z; from: 0; to: 180; dur: ' + this.data.mirrorDuration);
    mirror.setAttribute('animation__fadeout',
      `property: material.opacity; from: 1; to: 0; dur: 1000; delay: ${this.data.mirrorDuration - 1000}`);
    
    parent.appendChild(mirror);
    
    // Remove mirror after fade
    setTimeout(() => {
      if (mirror.parentNode) mirror.parentNode.removeChild(mirror);
    }, this.data.mirrorDuration + 100);
  },

  remove: function () {
    const el = this.el;
    el.removeEventListener('click', this.onInteract);
    el.removeEventListener('touchstart', this.onInteract);
    
    if (this.mirrorVideo && this.mirrorVideo.srcObject) {
      this.mirrorVideo.srcObject.getTracks().forEach(track => track.stop());
    }
  }
});

    // --------- Random bubble ring ---------- 
    AFRAME.registerComponent('random-bubble-ring', {
      schema: {
        count:        { default: 8 },
        radius:       { default: 5 },
        y:            { default: 0 },
        scale:        { default: 9 },

        radiusJitter: { default: 1.0 },
        heightJitter: { default: 1.0 },
        depthJitter:  { default: 1.2 },
        scaleJitter:  { default: 0.9 }
      },

      init() {
        const data = this.data;

        for (let i = 0; i < data.count; i++) {
          const angle = (i / data.count) * Math.PI * 2;

          // radial position
          const radialOffset = (Math.random() - 0.5) * data.radiusJitter;
          const r = data.radius + radialOffset;
          let x = Math.cos(angle) * r;
          let z = Math.sin(angle) * r;

          // depth jitter
          const depthOffset = (Math.random() - 0.5) * data.depthJitter;
          z += depthOffset;

          // height jitter
          const y = data.y + (Math.random() - 0.5) * data.heightJitter;

          // scale jitter
          const scaleFactor = 1 - data.scaleJitter / 2 + Math.random() * data.scaleJitter;
          const finalScale = data.scale * scaleFactor;

          const bubble = document.createElement('a-entity');
          bubble.setAttribute('gltf-model', '#bubbleModel');
          bubble.setAttribute('force-phong', '');
          bubble.setAttribute('bubble-pop', ''); // every ring bubble is poppable
          bubble.setAttribute('position', `${x} ${y} ${z}`);
          bubble.setAttribute('scale', `${finalScale} ${finalScale} ${finalScale}`);

          bubble.setAttribute(
            'rotation',
            `${(Math.random() - 0.5) * 20} ${(Math.random()*360).toFixed(1)} ${(Math.random() - 0.5) * 20}`
          );

          this.el.appendChild(bubble);
        }
      }
    });
  </script>
</head>

<body>
  <a-scene
    embedded
    vr-mode-ui="enabled:false"
    renderer="logarithmicDepthBuffer:true;antialias:true;colorManagement:true;physicallyCorrectLights:true;toneMapping:ACESFilmic;exposure:1.9"
    arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled:false">

    <!-- Camera with visible ring cursor and ray from mouse/touch -->
    <a-camera cursor="rayOrigin: mouse; fuse: false"
              raycaster="objects: .clickable; far: 100">
      <a-entity geometry="primitive: ring; radiusInner: 0.01; radiusOuter: 0.02"
                material="color: #FFFFFF; shader: flat; opacity: 0.9"
                position="0 0 -1">
      </a-entity>
    </a-camera>

    <!-- Assets -->
    <a-assets timeout="60000">
      <a-asset-item id="bubbleModel" src="wobble5.glb"></a-asset-item>
      <a-asset-item id="bubbleSplitModel" src="BubbleSplit.glb"></a-asset-item>
    </a-assets>

    <!-- Lights -->
    <a-entity light="type:ambient; intensity:10; color:#FA7AAE"></a-entity>

    <a-entity position="1 2 -1"
              light="type:directional; intensity:8; color:#8BFCFC"></a-entity>

    <a-entity position="-2 2 1"
              light="type:directional; intensity:8; color:#E65E63"></a-entity>

    <a-entity position="0.5 0.6 -0.8"
              light="type:point; intensity:10; distance:4; color:#FFFFFF"></a-entity>

    <a-entity light="type:hemisphere; color:#AAFFFF; groundColor:#0088FF; intensity:2.5"></a-entity>

    <!-- Floating + spinning bubble sculpture -->
    <a-entity
      id="bubble-sculpture"
      position="0 -0.5 -6"
      scale="1 1 1"
      animation__float="property: position.y; from:-0.8; to:0.8; dur:14000; dir:alternate; loop:true; easing:easeInOutSine">

      <!-- Center bubble (also poppable) -->
      <a-entity gltf-model="#bubbleModel"
                force-phong
                bubble-pop
                position="0 0 0"
                scale="15 15 15">
      </a-entity>

      <!-- Outer ring -->
      <a-entity
        id="ring-outer"
        animation__spin="property: rotation.y; to:360; loop:true; dur:50000; easing:linear"
        random-bubble-ring="count:10; radius:3; y:0; scale:6;
                            radiusJitter:1.5; heightJitter:1.2; depthJitter:1.5; scaleJitter:0.8">
      </a-entity>

      <!-- Upper ring -->
      <a-entity
        id="ring-upper"
        animation__spin="property: rotation.y; to:-360; loop:true; dur:60000; easing:linear"
        random-bubble-ring="count:8; radius:2.6; y:2.0; scale:6;
                            radiusJitter:0.8; heightJitter:0.8; depthJitter:1.0; scaleJitter:0.4">
      </a-entity>

      <!-- Lower ring -->
      <a-entity
        id="ring-lower"
        animation__spin="property: rotation.y; to:360; loop:true; dur:55000; easing:linear"
        random-bubble-ring="count:8; radius:2.4; y:-2.0; scale:6;
                            radiusJitter:1.0; heightJitter:1.0; depthJitter:1.3; scaleJitter:0.6">
      </a-entity>

    </a-entity>

  </a-scene>
</body>
</html>
